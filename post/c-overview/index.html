<!doctype html><html lang=en><head><title>C Overview &ndash; thinking-space</title>
<meta name=description content="Programming is thinking not typing."><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=UTF-8><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.4/css/academicons.min.css integrity="sha512-IW0nhlW5MgNydsXJO40En2EoCkTTjZhI3yuODrZIc8cQ4h1XcF53PsqDHa09NqnkXuIe0Oiyyj171BqZFwISBw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cunfus.github.io/css/palettes/base16-dark.css><link rel=stylesheet href=https://cunfus.github.io/css/risotto.css><link rel=stylesheet href=https://cunfus.github.io/css/custom.css><link rel=icon href=https://cunfus.github.io/favicon.ico><link rel=icon type=image/png sizes=32x32 href=https://cunfus.github.io/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=https://cunfus.github.io/favicon-16x16.png><link rel=apple-touch-icon href=https://cunfus.github.io/apple-touch-icon.png><link rel=manifest href=https://cunfus.github.io/site.webmanifest></head><body><div class=page><header class=page__header><nav class="page__nav main-nav"><ul><li class=nomarker><h1 class=page__logo><a href=https://cunfus.github.io/ class=page__logo-inner>thinking-space</a></h1></li><li class=main-nav__item><a class=nav-main-item href=https://cunfus.github.io/about/ title>About</a></li><li class=main-nav__item><a class="nav-main-item active" href=https://cunfus.github.io/post/ title=Posts>Posts</a></li></ul></nav></header><section class=page__body><header class=content__header><h1>C Overview</h1></header><div class=content__body><h2 id=工具链>工具链</h2><p>推荐书籍 <em>21st Century C</em>。工具链从基础的编译调试，到打包、测试、文档和版本控制。</p><ul><li>编译器 - gcc</li><li>调试器 - gdb</li><li>性能分析 - 内存/覆盖率 - valgrind asan</li><li>编译工具 - 避免直接使用编译器 - makefile</li><li>文档 - doxygen</li><li>单元测试 - gtest minunit</li><li>版本控制 - git</li></ul><h2 id=运作逻辑>运作逻辑</h2><p>推荐书籍 <em>程序员的自我修养-链接、装载与库</em>，这里需要弄懂两个问题。</p><ul><li>在磁盘中，可执行程序是什么样子？</li><li>在内存中，可执行程序是什么样子？</li></ul><h3 id=堆栈与内存泄漏>堆/栈与内存泄漏</h3><p>堆，地址向上增长，malloc 分配内存，calloc 分配清零后的内存，realloc 扩大缩小分配的内存（一般是重分配，返回指针）。free 释放分配的内存。而且申请内存时，一般会返回 2 的整数次方的内存大小。可以察觉到，反反复复的申请释放，会产生内存碎片，于是就有了内存池来优化。</p><p>栈，地址向下增长，存储函数实参和局部变量，函数调用的链接信息（去执行另一个函数时，存储当前信息，方便返回）。</p><p>栈帧，是函数运行时，占用的栈资源。如函数 A 调用函数 B，会在栈中压入返回地址，B 的参数，B 的局部变量，等到 B 运行完后，以相反的顺序销毁，然后根据返回地址，回到 A。可以想象，在整个程序的运行期间，栈空间总是不断地增长和缩减，是动态的。
在 gdb 中进行多线程调试时， <code>info threads</code> 查看有哪些线程， <code>thread num</code> 切换到指定的线程， <code>bt</code> 打印当前线程的函数调用栈， <code>f num</code> 进入指定的帧，一个帧对应执行过程中一个特定的函数调用，可以查看局部变量、参数、调用关系。</p><p>还可以通过 <code>cat /proc/#num/maps</code>查看进程的内存空间分布。</p><p>堆溢出，不断 malloc 内存，但是不销毁，达到上限，或者越界访问。
栈溢出，递归调用层次太多，局部数组过大，越界访问。</p><ul><li>释放或改写仍在使用的内存，内存损坏</li><li>未释放不再使用的内存，内存泄漏。</li></ul><h2 id=语言特性>语言特性</h2><p>推荐书籍 <em>Expert C Programming</em>，</p><h3 id=structunion>struct/union</h3><p>结构体</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> veg_tag { <span style=color:#66d9ef>float</span> weight; <span style=color:#66d9ef>double</span> price; };
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> veg_tag veg_a, veg_b, veg_c;
</span></span></code></pre></div><p>union 同一主体，不同解释</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>union</span> bit_tag { <span style=color:#66d9ef>int</span> i; <span style=color:#66d9ef>char</span> c[<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>)]; };
</span></span><span style=display:flex><span><span style=color:#66d9ef>union</span> bit_tag test;
</span></span><span style=display:flex><span>test.i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (test.c[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) <span style=color:#75715e>// 读到的第一个是低位字节，小端模式
</span></span></span></code></pre></div><h3 id=类型>类型</h3><p><code>char * const * (*next)();</code>, next 是一个函数指针，这个函数的形参列表是空，返回值是另一个指针，指向 char 型的常量指针。先考虑变量名，先右后左判断。</p><p><code>char * (*c[10])(int **p);</code>, c 是一个 10 个元素的数组，数组元素是函数指针，这个函数的形参是二级 int 指针，函数的返回值是一个指向 char 的指针。</p><p>typedef 简洁指向其他类型的指针。</p><p><code>void (*signal(int sig, void(*func)(int)))(int);</code>，signal 是一个函数，它返回了一个函数指针，这个指针指向的函数接受 int 参数，返回 void。signal 函数的参数 void(*func)(int)，接受 int，返回 void。
用 typedef 来简化一下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#a6e22e>void</span>(<span style=color:#f92672>*</span>func_ptr)(<span style=color:#66d9ef>int</span>);  <span style=color:#75715e>/* func_ptr : void(*)(int) */</span>
</span></span><span style=display:flex><span>func_ptr <span style=color:#a6e22e>signal</span>(<span style=color:#66d9ef>int</span>, func_ptr);
</span></span></code></pre></div><p>不要滥用 typedef，不然你会疯的。</p><p>那么，typedef 和 define 区别，宏是文本的替换，typedef 是给<strong>类型</strong>起别名。typedef 是一种彻底的封装，封装后不能再加<strong>类型前缀</strong>（unsigned）使用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define int_ptr int *
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>int_ptr x, y; <span style=color:#75715e>// x 是 int 指针， y 是 int， 不彻底的封装
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>int_prt;
</span></span><span style=display:flex><span>int_ptr x, y; <span style=color:#75715e>// x, y 都是 int 指针， 是彻底的封装
</span></span></span></code></pre></div><p>typedef 使用的结构类型，如 <code>typedef struct fruit {} fruit_type; fruit_type apple;</code>。</p><h3 id=变长柔性数组c99>变长/柔性数组（c99）</h3><p>由于出栈会自动释放内存，在栈上申请空间，不用考虑主动释放的问题，alloca 就是这个作用，但这个调用不具有可移植性，所以，C99增加了变长数组，就是允许使用变量代替维度。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> y <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> pos[x][y];
</span></span></code></pre></div><p>C99 还支持了柔性数组，就是不完整类型的数组，维度可以推后确定（后面动态分配、重分配），</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> a[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> flex {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> c[];
</span></span><span style=display:flex><span>} f;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>f <span style=color:#f92672>*</span>pf <span style=color:#f92672>=</span> (f <span style=color:#f92672>*</span>)<span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(f) <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>char</span>) <span style=color:#f92672>*</span> <span style=color:#ae81ff>32</span>);
</span></span></code></pre></div><p>由于内存声明的连续性，这种不完全声明必须放到最后一个，且不能是唯一的成员。这个用来解决数组变长的问题，以及越界的问题。</p><p>sizeof(f) = 4, 不包括 c 这个柔性数组大小，即使 c 后面给了内存空间也是。如果空间需要调整，可以用 realloc 重分配空间。
<code>f* new_pf = (f *)realloc(pf, sizeof(f) + sizeof(char)* 64);</code></p><p>这样，就可以一次分配，一次释放。连续的内存便于访问，提高运行速度，和减少内存碎片。</p><h3 id=内存对齐>内存对齐</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> foo {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>int</span> x;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>char</span> c;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>int</span> y;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>按理说这个结构大小是 9 字节（4+1+4），但实际是 12 字节（4+4+4），这就是内存对齐，方便机器读取。</p><p>怎么节省空间，一种是使用 gcc 的 attribute 机制，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> foo {
</span></span><span style=display:flex><span>   ...
</span></span><span style=display:flex><span>} <span style=color:#a6e22e>__attribute__</span>((packed));
</span></span></code></pre></div><p>或者使用 <code>pragma pack(size)</code>，指定最小对齐大小，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#pragma pack(push)  </span><span style=color:#75715e>// 保存对齐状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#pragma pack(4)     </span><span style=color:#75715e>// 设定为 4 字节对齐
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> test
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> m1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> m4;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> m3;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#pragma pack(pop)   </span><span style=color:#75715e>// 恢复对齐状态
</span></span></span></code></pre></div><p>如上，pack(4) 是 16, pack(1) 是 13。</p><p>还有一种是 bit-filed，制定每个占用空间的占用字节大小，位域不能设定超出类型大小的数值，如int-32 char-8。并且编译器仍然会自动对齐，只是规定了类型中可供使用的空间</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> foo {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x:<span style=color:#ae81ff>16</span>;  <span style=color:#75715e>/* 0x11111111 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> c:<span style=color:#ae81ff>8</span>;  <span style=color:#75715e>/* &#39;a&#39; */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> y:<span style=color:#ae81ff>16</span>;  <span style=color:#75715e>/* 0x22222222 */</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(gdb) x<span style=color:#f92672>/</span><span style=color:#ae81ff>8</span>xb <span style=color:#f92672>&amp;</span>foo
</span></span><span style=display:flex><span><span style=color:#ae81ff>0x7fffffffd59c</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0x11</span>    <span style=color:#ae81ff>0x11</span>    <span style=color:#ae81ff>0x61</span>    <span style=color:#ae81ff>0x00</span>    <span style=color:#ae81ff>0x22</span>    <span style=color:#ae81ff>0x22</span>    <span style=color:#ae81ff>0xff</span>    <span style=color:#ae81ff>0xff</span>                                              
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> foo {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x:<span style=color:#ae81ff>32</span>;  <span style=color:#75715e>/* 0x11111111 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> c:<span style=color:#ae81ff>8</span>;  <span style=color:#75715e>/* &#39;a&#39; */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> y:<span style=color:#ae81ff>32</span>;  <span style=color:#75715e>/* 0x22222222 */</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(gdb) x<span style=color:#f92672>/</span><span style=color:#ae81ff>12</span>xb <span style=color:#f92672>&amp;</span>foo
</span></span><span style=display:flex><span><span style=color:#ae81ff>0x7fffffffd598</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0x11</span>    <span style=color:#ae81ff>0x11</span>    <span style=color:#ae81ff>0x11</span>    <span style=color:#ae81ff>0x11</span>    <span style=color:#ae81ff>0x61</span>    <span style=color:#ae81ff>0x7f</span>    <span style=color:#ae81ff>0x00</span>    <span style=color:#ae81ff>0x00</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0x7fffffffd5a0</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>0x22</span>    <span style=color:#ae81ff>0x22</span>    <span style=color:#ae81ff>0x22</span>    <span style=color:#ae81ff>0x22</span>
</span></span></code></pre></div><h2 id=最佳实践>最佳实践</h2><h3 id=错误处理>错误处理</h3><p>业务上的代码，经常在函数开始时，判断参数是否出错，（如果出错）跳转到清理函数（通常是释放内存），如下，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>if</span> ()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>goto</span> error;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> ()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>goto</span> error;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>process</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>error:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>clean</span>();
</span></span></code></pre></div><p>这样写很麻烦，而且用 goto 味道不太好。可以采用 <code>do {} while(0)</code>, 发生错误后 break 出去，如下，</p><pre tabindex=0><code>do {
    if ()
        break;

    process();

} while(0);

clean();
</code></pre><h3 id=结构体数组表驱动>结构体数组/表驱动</h3><p><strong>enum 存储状态</strong>，这个在状态转移中经常用到，</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>enum</span> State {
</span></span><span style=display:flex><span>    HTTP_403,
</span></span><span style=display:flex><span>    HTTP_404,
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>进一步，在结构体数组中，存储同一类信息，方便在一处修改。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    State state;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>info;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> (<span style=color:#f92672>*</span>func)(<span style=color:#66d9ef>int</span>);
</span></span><span style=display:flex><span>} Stage;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Stage <span style=color:#f92672>*</span>vec[] <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    { HTTP_403, <span style=color:#e6db74>&#34;403&#34;</span>, action_403 }<span style=color:#960050;background-color:#1e0010>，</span>
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>表驱动，就是将过程放入一张表中，将原来需要 switch 或 if else 判断的逻辑简化。可以借助刚刚的结构体数组实现。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> tableEntry {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> input;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> output;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> tableEntry table[] <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>403</span>},
</span></span><span style=display:flex><span>    {<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>404</span>},
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=extern-c>extern &ldquo;C&rdquo;</h3><p>不管是 C 调用 C++，还是 C++ 调用 C, 因为两边的符号修饰系统不一样，因此，需要对被调用的部分，加上 <code>extern "C" { }</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#ifdef __cplusplus
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>extern</span> <span style=color:#e6db74>&#34;C&#34;</span> {
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>func</span>(<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef __cplusplus
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span></code></pre></div></div><footer class=content__footer></footer></section><section class=page__aside><div class=aside__about><div class=aside__about><span class=about__logo role=img>🍚</span>&nbsp;<h1 class=about__title>Cunfus</h1><p class=about__description>Programming is thinking not typing.</p></div><ul class=aside__social-links><li><a href=https://github.com/cunfus rel=me aria-label=GitHub title=GitHub><i class="fa-brands fa-github" aria-hidden=true></i></a>&nbsp;</li><li><a href=mailto:cunfuss@outlook.com rel=me aria-label=Email title=Email><i class="fa-solid fa-envelope" aria-hidden=true></i></a>&nbsp;</li></ul></div><hr><div class=aside__content><p>By Cunfus,
2024-07-21</p><hr>On this page:<nav id=TableOfContents><ol><li><a href=#工具链>工具链</a></li><li><a href=#运作逻辑>运作逻辑</a><ol><li><a href=#堆栈与内存泄漏>堆/栈与内存泄漏</a></li></ol></li><li><a href=#语言特性>语言特性</a><ol><li><a href=#structunion>struct/union</a></li><li><a href=#类型>类型</a></li><li><a href=#变长柔性数组c99>变长/柔性数组（c99）</a></li><li><a href=#内存对齐>内存对齐</a></li></ol></li><li><a href=#最佳实践>最佳实践</a><ol><li><a href=#错误处理>错误处理</a></li><li><a href=#结构体数组表驱动>结构体数组/表驱动</a></li><li><a href=#extern-c>extern &ldquo;C&rdquo;</a></li></ol></li></ol></nav></div></section><footer class=page__footer><p class=copyright>© <a href=https://cunfus.github.io>Cunfus</a> 2024</p><p class=advertisement>Powered by <a href=https://gohugo.io/>hugo</a> and <a href=https://github.com/joeroe/risotto>risotto</a>.</p></footer></div></body></html>